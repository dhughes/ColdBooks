Validation rules to add:
	1) need to be able to reach the QBWC url
	2) no two connections with the same name
	3) validate the connection url is a URL
	4) insure the connectionID is unique
	5) if either scheduler value provided both required
	
view QuickBooks like a datasource, not like a service, perse within the CF administrator

To install this, the user would drop a folder under the CFIDE folder and browse to its index. 
	For example: http://whatever.com/CFIDE/qbwc
	
	If not alrady done, this will do the initial configuration which includes:
		1) Creating an XML file to store the connections in
		2) Updating the links XML in the CF admin to add the QB stuff.
		
	All other times going to this directory will redirect to the admin

Create an admin interface where a user can create a connection to quickbooks.
	This would work by asking you to provide some specific information including:
		- connection name: this would be a name for the connection used to uniquely idenfify this connection
		- connection description: this would be a required description of the connection
		- support url: an required URL for more information (must be on same domain as the service itself)
		- owner id: defaults to a generated UUID but can be manually changed to another.
		- personal data option: yes, optional, required
		- read only: a checkbox to indicate readonly-ness (for version 1 I may assume this is never read only)
		- dsn name: this is the name of an already-existing dsn that will be used to store qb data
		- qbwc password: this is the password a user will need to type in to connect to the service
		- quickbooks type: this is either quickbooks financial or point of sale (may only support financial initially)
		- run interval: every x seconds or minutes or blank if not needed
		
	This will record configuration information for a given connection and a QWC file with the following information:
		- AppDescription - the description provided above
		- AppName - the name of the connection as provided above
		- AppSupport - the URL provided above
		- AppURL - the URL generated by the configuration for the web service
		- FileID - generated UUID
		- IsReadOnly - indicates readonlyness
		- OwnerId - generated or UUID provided above (this might not be 100% correct, but the idea is to name a specific connection)
		- PersonalDataPref - based on configuration value gathered
		- Scheduler - scheduler info, if provided
		- Style - RPC
		- UnattendedModePref - umpRequired
		- username - always QBWCCF
		
	The new connection will show:
		- The name of the connection
		- The dsn connected to
		- The web service URL (under the support domain provided and indicate if it can be reached or not via HTTPS)
		- Last time updated
		- A link to download the QWC file
		- edit, delete links
		
	Behind the scenes, this will create a record in the XML configuration file created when this was initially configured.
	
	Programmers will be able to use a factory to get ahold of the specific QB connection they want.
	This will be a service object or a set of service objects for each major type.  Reading will pull data 
	from the DSN specified in the connection.  Writing will write data to the database.
	
	When the QBWC connects to the serivce it will specifiy which applicaiton this is, which will identify the 
	datasource and updates will be synchronized for ALL objects.  
----------
File Patterns:

QBA - America?
QBC - Canada?
QBO - Online?
QBU - UK?
no prefix - ??




qbxml 	= quickbooks (US)
QBC 	= canada
QBU		= UK

need to test some changes for QB Canada and UK.... specifically the xml version decleration

QBO 	= quickbooks online
QWC 	= quickbooks web connector (QWC files)

for now I'm thinking we dont support POS or MS

query
add
del
mod

Start by parsing the qbxmlops file find any xsd:element with name in "RqType" 
	these are all the types of requests that can be made.  I may actually want to generate 
	objects for these.
	
	Then, in the QBWC.cfc I can create a QBXMLMsgsRq, populate that with queries, and send them 
	down to QB to get all my data back.  I may even be able to filter the data returned to save 
	bandwidth.  By sending them back, I mean to serialize them to XML.
	
	The XML that comes back from QB could be deserialized into these generated objects.  So, I'd
	end up with a QBXMLMsgsRs object containing one or more other response objects.  Each which 
	might contain one or more other objects.  
	
	So, as a scenerio, when the QBWC connects, I request all the types of queries (but only for
	the last updated time, etc) by essentially having on method which creates all these objects.
	I then serialize it and get the XML I'm going to send down.
	
	QB gets this XML, realizes I need a little of everything, makes a big XML file, and sends it
	up.  I deserialize this into a set of objects.  So, as an example I'd have:
	QBXMLMsgsRs
		-> CompanyQueryRs
			-> CompanyRet
		-> AccountQueryRs
			-> AccountRet
			
	etc, etc.
	
	Each of the Ret values would be used to populate an actual Account object that would be generated
	based on the Account types (AccountRet, AccountAdd & AccountMod combined).  This object would be
	persistable.  
	
	Somehow or other I'd compare what I got back to that in the database.  I'd identify any local 
	records needing updating and I'd use a service method like saveAccount(Account) to persist the 
	returned account locally.  Any records needing to be pushed down to QB will be added to a queue
	to be pushed down.  The adding to the queue will likely crate the various request objects needed
	somehow.
	
	users will be able to use the same service used above to save an account to list, get, and save
	any type of object.  The list method will accept any property of the object with any value and
	behind the scenes we'll use entityList() to search.  (Note: I'll need a Dao as well for each type
	of object).
	
	listObject(prop1, prop2, {prop=3}, etc) - returns a collection
	getObject(listId, prop2, prop3, etc) - returns a single element
	saveObject(Object) - creates or updates an existing object.  state of editsequence, etc, is automatically handled.
	
	
	
	

	


